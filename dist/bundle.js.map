{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/globals.js","webpack:///./src/sound.js","webpack:///./src/window.js","webpack:///./src/blob.js","webpack:///./src/game.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","window","GLOBALS","blobs","windowSize","horizontal","vertical","keyState","left","right","down","up","gameState","gravity","repulsion","drag","borderBounce","borderTeleport","player","pairwiseForceStrength","viewDistance","initialSize","initialPos","speedUp","diagonal","Math","sqrt","maxPop","appetite","G","R","minSize","borderElasticity","fps","audioDepth","sounds","soundIndex","push","Audio","getGameWindow","document","getElementById","blob_Blob","[object Object]","radius","position","velocity","isPlayer","pairwiseForce","this","mass","pow","force","moving","blobDiv","createElement","classList","add","appendChild","id","move","viscosity","accelerate","teleport","updateDiv","random","newRandomDirection","toggleMoving","angle","PI","power","cos","sin","style","bottom","height","width","abs","adjustment","parentNode","removeChild","other","weighting","newPosition","newVelocity","newRadius","deleteDiv","play","opac","opacity","a","b","fromCentre","centre","distance","getDistance","magnitude","forceTermHorizontal","forceTermVertical","game_blobs","game_t","game_windowSize","game_keyState","game_gameState","game_player","game_pairwiseForceStrength","game_viewDistance","game_initialSize","game_initialPos","game_speedUp","game_diagonal","game_maxPop","game_drag","game_appetite","game_G","game_R","game_minSize","game_borderElasticity","game_fps","toggleInstructions","toggle","playerDeath","forEach","blob","setOpacity","addBlob","pos","entryPoint","x","getRandomBorderPosition","vel","newblob","iteration","length","update","newBlobs","blobWander","biggerThan","currentForce","getForce","consume","setForce","max","pairwiseInteraction","j","updateWindowSize","windowDimensions","getBoundingClientRect","keyDown","e","keyCode","updatePlayerForce","keyUp","totalMomentum","totalCOM","totalMass","allBlobs","concat","currentMass","getMass","currentVelocity","getVel","currentPosition","getPos","velocityShift","positionShift","adjustVelocityBy","adjustPositionBy","zeroTotalMomentumAndPosition","keyPress","slice","onload","addEventListener","setInterval"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","window.GLOBALS = {\n  blobs: [],\n  t: null,\n  windowSize: {\n    horizontal: 0,\n    vertical: 0\n  },\n  keyState: {\n    left: false,\n    right: false,\n    down: false,\n    up: false,\n  },\n  gameState: {\n    gravity: false,\n    repulsion: false,\n    drag: true,\n    borderBounce: true,\n    borderTeleport: false,\n  },\n  player: null,\n  pairwiseForceStrength: 1,\n  viewDistance: 200,\n  initialSize: 10,\n  initialPos: [50, 50],\n  speedUp: 0.5,\n  diagonal: 1.0 / Math.sqrt(2),\n  maxPop: 10,\n  drag: 0.004,\n  appetite: 0.0005,\n  G: 0.5,\n  R: -0.5,\n  minSize: 10,\n  borderElasticity: 0.005,\n  fps: 50\n}","const audioDepth = 5;\nlet sounds = [],\n    soundIndex = 0;\nfor (let i = 0; i < audioDepth; i++) {\n  sounds.push(new Audio(\"sounds/bubble_pop.mp3\"))\n}\n\n// when blobs collide play this sound\nexport function playSound() {\n  soundIndex = (soundIndex+1)%audioDepth;\n  sounds[soundIndex].play();\n}","export function getGameWindow() {\n  return document.getElementById('game-display');\n}","import { playSound } from './sound'\nimport { getGameWindow } from './window'\n\nlet {\n  blobs,\n  t,\n  windowSize,\n  keyState,\n  gameState,\n  player,\n  pairwiseForceStrength,\n  viewDistance,\n  initialSize,\n  initialPos,\n  speedUp,\n  diagonal,\n  maxPop,\n  drag,\n  appetite,\n  G,\n  R,\n  minSize,\n  borderElasticity,\n  fps\n} = window.GLOBALS\n\nexport default class Blob {\n  constructor(radius, position, velocity = [0, 0], isPlayer = false, pairwiseForce = [0, 0]) {\n    this.radius = radius;\n    this.mass = Math.pow(radius, 3);\n    this.position = position;\n    this.velocity = velocity;\n    this.force = [0, 0];\n    this.isPlayer = isPlayer;\n    this.pairwiseForce = pairwiseForce;\n\n    // non player blob only\n    this.moving = false;\n\n    // creates a corresponding div to display on screen\n    this.blobDiv = document.createElement('div');\n    this.blobDiv.classList.add('blob');\n    getGameWindow().appendChild(this.blobDiv);\n\n    // sets the div id for player styling\n    if (isPlayer) {\n      this.blobDiv.id = 'player';\n    }\n  }\n\n  // this master call contains all the things that need to happen to each blob each iteration\n  update() {\n    this.move();\n    if (gameState.drag) this.viscosity();\n    // this.hunger();\n    this.accelerate();\n    if (gameState.borderTeleport) this.teleport();\n    if (gameState.borderBounce) this.borderBounce();\n    this.updateDiv();\n    // since the pairwise force is recalculated each iteration it needs to be rezeroed each time.\n    if (gameState.gravity || gameState.repulsion) this.pairwiseForce = [0, 0];\n  }\n\n  // based on the current state of arrow keys, set the force of the player\n  updatePlayerForce() {\n    if (keyState.up) {\n      if (keyState.left) {\n        //up and left\n        this.force = [-diagonal, diagonal];\n      } else if (keyState.right) {\n        // up and right\n        this.force = [diagonal, diagonal];\n      } else {\n        // straight up\n        this.force = [0, 1];\n      }\n    } else if (keyState.down) {\n      if (keyState.left) {\n        // down and left\n        this.force = [-diagonal, -diagonal];\n      } else if (keyState.right) {\n        // down and right\n        this.force = [diagonal, -diagonal];\n      } else {\n        // straight down\n        this.force = [0, -1];\n      }\n    } else if (keyState.right) {\n      // right\n      this.force = [1, 0];\n    } else if (keyState.left) {\n      // left\n      this.force = [-1, 0];\n    } else {\n      this.force = [0, 0]\n    }\n  }\n\n  // this function creates the random blob movement\n  blobWander() {\n    // if the blob is moving it has a chance of changing direction\n    if (this.moving && Math.random() > 0.95) {\n      this.newRandomDirection();\n    }\n    // it also has a chance to start or stop moving\n    if (Math.random() > 0.993) {\n      this.toggleMoving();\n    }\n  }\n\n  newRandomDirection() {\n    let angle = Math.random() * 2 * Math.PI;\n    let power = Math.random();\n    this.force[0] = Math.cos(angle) * power;\n    this.force[1] = Math.sin(angle) * power;\n  }\n\n  toggleMoving() {\n    this.moving = !(this.moving);\n  }\n\n  // definitely unnecessary but I'll levae in case\n  getAbsVel() {\n    return Math.sqrt(Math.pow(this.velocity[0], 2) + Math.pow(this.velocity[1], 2));\n  }\n\n  // update the div position and size, this is what effectively links the javascript object to the DOM\n  updateDiv() {\n    this.blobDiv.style.left = (this.position[0] - this.radius) + 'px';\n    this.blobDiv.style.bottom = (this.position[1] - this.radius) + 'px';\n    this.blobDiv.style.height = this.radius * 2 + 'px';\n    this.blobDiv.style.width = this.radius * 2 + 'px';\n  }\n\n  // This function updates the blobs position from it's current speed and position \n  move() {\n    this.position[0] += this.velocity[0];\n    this.position[1] += this.velocity[1];\n  }\n\n  // This function decellerates the as a function of its radius and velocity, this means bigger blobs are slower\n  viscosity() {\n    // this.velocity[0] *= (1-drag*Math.sqrt(this.radius)*Math.pow(this.velocity[0],2));\n    // this.velocity[1] *= (1-drag*Math.sqrt(this.radius)*Math.pow(this.velocity[1],2));\n    this.velocity[0] *= (1 - drag * Math.sqrt(this.radius) * Math.abs(this.velocity[0]));\n    this.velocity[1] *= (1 - drag * Math.sqrt(this.radius) * Math.abs(this.velocity[1]));\n  }\n\n  // gradually shrinks blob as long as it is above a minimum size\n  hunger() {\n    if (this.radius > minSize) {\n      this.radius *= (1 - appetite);\n    }\n  }\n\n  // these functions are necessary because this isn't quite a regular object but a 'class', this means\n  // that from the global context blob properties can't be set manually (blob[0].radius = x), they \n  // have to be asked politely for information and be asked to change\n  getRadius() {\n    return this.radius;\n  }\n  getMass() {\n    return this.mass;\n  }\n  getVel() {\n    return this.velocity;\n  }\n  getPos() {\n    return this.position;\n  }\n  getForce() {\n    return this.force;\n  }\n  setForce(force) {\n    this.force = force;\n  }\n  adjustVelocityBy(adjustment) {\n    this.velocity[0] += adjustment[0];\n    this.velocity[1] += adjustment[1];\n  }\n  adjustPositionBy(adjustment) {\n    this.position[0] += adjustment[0];\n    this.position[1] += adjustment[1];\n  }\n\n  // accelerate the blob\n  accelerate() {\n    // this component is the blobs own movement, player or otherwise\n    if (gameState.drag) {\n      this.velocity[0] += speedUp * this.force[0];\n      this.velocity[1] += speedUp * this.force[1];\n    }\n    // this is the effect of pairwise forces on the blob\n    if (gameState.gravity || gameState.repulsion) {\n      this.velocity[0] += this.pairwiseForce[0] / this.mass;\n      this.velocity[1] += this.pairwiseForce[1] / this.mass;\n    }\n  }\n\n  // this function handles what happens when a blob nears the edge of screen\n  borderBounce() {\n    // if the blob is off the left hand side of the screen\n    if (this.position[0] < -this.radius) {\n      // apply force proportional to it's distance off screen\n      this.velocity[0] -= borderElasticity * (this.position[0] + this.radius);\n      // and vice versa\n    } else if (this.position[0] > this.radius + windowSize.horizontal) {\n      this.velocity[0] -= borderElasticity * (this.position[0] - this.radius - windowSize.horizontal);\n    }\n\n    // same for vertical\n    if (this.position[1] < -this.radius) {\n      this.velocity[1] -= borderElasticity * (this.position[1] + this.radius);\n    } else if (this.position[1] > this.radius + windowSize.vertical) {\n      this.velocity[1] -= borderElasticity * (this.position[1] - this.radius - windowSize.vertical);\n    }\n  }\n\n  // When a blob leaves the screen, teleport it to the other side.\n  teleport() {\n    this.position[0] = ((this.position[0] + windowSize.horizontal) % (windowSize.horizontal));\n    this.position[1] = ((this.position[1] + windowSize.vertical) % (windowSize.vertical));\n  }\n\n  deleteDiv() {\n    this.blobDiv.parentNode.removeChild(this.blobDiv);\n  }\n\n  biggerThan(other) {\n    return (this.radius >= other.radius);\n  }\n\n  // given two blobs, this function returns a single blob such that mass, centre of mass and momentum are conserved\n  consume(other) {\n    // relative mass\n    let weighting = Math.pow(other.radius, 3) / (Math.pow(this.radius, 3) + Math.pow(other.radius, 3));\n    // calculates centre of mass of both blobs\n    let newPosition = [\n      this.position[0] + (other.position[0] - this.position[0]) * weighting,\n      this.position[1] + (other.position[1] - this.position[1]) * weighting\n    ];\n    // calculates velocity based on total momentum\n    let newVelocity = [\n      this.velocity[0] + (other.velocity[0] - this.velocity[0]) * weighting,\n      this.velocity[1] + (other.velocity[1] - this.velocity[1]) * weighting\n    ];\n\n    // new size that conserves mass|volume\n    let newRadius = Math.pow((Math.pow(this.radius, 3) + Math.pow(other.radius, 3)), 1 / 3);\n\n    // removes old divs from html\n    other.deleteDiv();\n    this.deleteDiv();\n\n    playSound();\n\n    // returns new Blob\n    return new Blob(\n      newRadius,\n      newPosition,\n      newVelocity,\n      (this === player)\n    );\n  }\n\n  setOpacity(opac) {\n    this.blobDiv.style.opacity = opac;\n  }\n\n  // This function checks how far apart two blobs are, either their surfaces or their centres\n  static getDistance(a, b, fromCentre) {\n    var centre = Math.sqrt(\n      Math.pow((a.position[0] - b.position[0]), 2) +\n      Math.pow((a.position[1] - b.position[1]), 2)\n    );\n    if (fromCentre) return centre;\n    else return (centre - (a.radius + b.radius));\n  }\n\n  // deal with all pairwise interactions between blobs, assumes player will be passed first if at all (player)\n  static pairwiseInteraction(a, b) {\n    // gravity and repulsion interaction\n    if (gameState.gravity || gameState.repulsion) {\n      let distance = Blob.getDistance(a, b, true),\n        magnitude = pairwiseForceStrength * a.mass * b.mass / Math.pow(distance, 2);\n\n      let forceTermHorizontal = magnitude * (a.position[0] - b.position[0]) / distance,\n        forceTermVertical = magnitude * (a.position[1] - b.position[1]) / distance;\n\n      a.pairwiseForce[0] -= forceTermHorizontal;\n      a.pairwiseForce[1] -= forceTermVertical;\n      b.pairwiseForce[0] += forceTermHorizontal\n      b.pairwiseForce[1] += forceTermVertical;\n    }\n  }\n}","import Blob from './blob'\nimport { getGameWindow } from './window'\n\nlet {\n  blobs,\n  t,\n  windowSize,\n  keyState,\n  gameState,\n  player,\n  pairwiseForceStrength,\n  viewDistance,\n  initialSize,\n  initialPos,\n  speedUp,\n  diagonal,\n  maxPop,\n  drag,\n  appetite,\n  G,\n  R,\n  minSize,\n  borderElasticity,\n  fps\n} = window.GLOBALS\n\nexport default function start() {\n  updateWindowSize();\n\n  document.addEventListener('keydown', keyDown, false);\n  document.addEventListener('keyup', keyUp, false);\n  document.addEventListener('keypress', keyPress, false);\n\n  window.addEventListener('resize', updateWindowSize, false);\n\n  toggleInstructions();\n\n  setInterval(iteration, 1000 / fps)\n};\n\nfunction createPlayer() {\n  player = new Blob(\n    initialSize,\n    // the slice makes sure a copy of the array is being passed, otherwise location and speed persist through death\n    initialPos.slice(),\n    [0, 0],\n    true\n  );\n}\n\nfunction toggleInstructions() {\n  document.getElementById('instructions').classList.toggle('hidden');\n}\n\n// this function gets called several times a second and has to loop through everything to make the game real time\nwindow.iteration = function() {\n  // add new blobs\n  repopulate();\n\n  // player movement\n  if (player) {\n    player.update();\n    // this updates the range of view of the player\n    viewDistance = initialSize * 10 + player.radius * 5;\n  }\n\n  // Each time the array is iterated through a new array is created,\n  // This is because when I tried to use array.filter the resultant array was still the same length and contained nulls\n  var newBlobs = [];\n\n  // this loop applies to every blob (except for possible player) in the game\n  for (var i = 0; i < blobs.length; i++) {\n    // it might be null, skip if it is\n    if (!blobs[i]) continue;\n\n    // this function creates random blob movement\n    blobs[i].blobWander();\n    // moves blob, applies all forces\n    blobs[i].update();\n\n    if (player) {\n      let distance = Blob.getDistance(player, blobs[i], false);\n      // if blob is touching player\n      if (distance < 0) {\n        if (player.biggerThan(blobs[i])) {\n          // combine blobs, create new player blob and carry over force\n          var currentForce = player.getForce();\n          player = player.consume(blobs[i]);\n          player.setForce(currentForce);\n          // player.updateDiv();\n\n          blobs[i] = null;\n          //  in this case the blob is now null so we want to skip to the next blob in the array\n          continue;\n        } else {\n          // eaten! in this case we keep updating the other blobs so there is no continue statement\n          blobs[i] = blobs[i].consume(player);\n          playerDeath();\n        }\n        // if not touching player\n      } else {\n        // apply opacity to the blob so that it gradually comes into view only near the player\n        blobs[i].setOpacity(Math.max(1 - (distance / viewDistance), 0));\n        // apply gravity or repulsion in this function\n        Blob.pairwiseInteraction(player, blobs[i]);\n      }\n    }\n\n    // This loop runs for every PAIR of blobs\n    for (var j = i + 1; j < blobs.length; j++) {\n      // skip null blobs\n      if (!blobs[j]) continue;\n      // are they touching\n      if (Blob.getDistance(blobs[i], blobs[j], false) < 0) {\n        // bigger eats smaller\n        (blobs[i].biggerThan(blobs[j])) ? blobs[i] = blobs[i].consume(blobs[j]) : blobs[i] = blobs[j].consume(blobs[i]);\n        blobs[j] = null;\n      } else {\n        Blob.pairwiseInteraction(blobs[i], blobs[j]);\n      }\n    }\n    // make sure the remaining blob gets carried to the next array\n    newBlobs.push(blobs[i]);\n  }\n\n  // the array is updated with remaining blobs in an array with no nulls\n  blobs = newBlobs;\n}\n\nfunction playerDeath() {\n  player = null;\n  toggleInstructions();\n  revealAll();\n}\n\n// reveal all blobs on page\nfunction revealAll() {\n  blobs.forEach(blob => {\n    blob.setOpacity(1);\n  })\n}\n\n// adds new blobs randomly as long as the max populatoin isn't reached\nfunction repopulate() {\n  if (blobs.length < maxPop && Math.random() > 0.99) addBlob();\n}\n\n// adds one new blob, can be given manual properties but defaults to random\nfunction addBlob(radius = getCreationRadius(), pos = getRandomBorderPosition(), vel = getRandomStartingVelocity()) {\n  let newblob = new Blob(\n    radius,\n    pos,\n    vel,\n    false\n  );\n  // put it in with its mates\n  blobs.push(newblob);\n}\n\n// creates entry point for new point along border\nfunction getRandomBorderPosition() {\n  let entryPoint;\n  let x = Math.random() * 4;\n  if (x < 1) {\n    entryPoint = [0, windowSize.vertical * x];\n  } else if (x < 2) {\n    entryPoint = [windowSize.horizontal * (x - 1), 0];\n  } else if (x < 3) {\n    entryPoint = [windowSize.horizontal, windowSize.vertical * (x - 2)];\n  } else {\n    entryPoint = [windowSize.horizontal * (x - 3), 0];\n  }\n  return entryPoint;\n}\n\n// creates random starting velocity\nfunction getRandomStartingVelocity() {\n  return [Math.random() * 4 - 2, Math.random() * 4 - 2];\n}\n\n// This function defines the distribution of sizes of new blobs\nfunction getCreationRadius() {\n  // 0.8*initialSize means the smallest created is just under player starting size,\n  // 5^(random^2) means the biggest size possible is 5 times the start size and the distribution is highly weighted towards smaller sizes\n  return 0.8 * initialSize * Math.pow(5, Math.pow(Math.random(), 2));\n}\n\n// this function gets called when the window size changes, it is mainly so that the player starting point gets updated\nwindow.updateWindowSize = function () {\n  let windowDimensions = getGameWindow().getBoundingClientRect();\n  windowSize.horizontal = windowDimensions.width;\n  windowSize.vertical = windowDimensions.height;\n  initialPos = [windowSize.horizontal / 2, windowSize.vertical / 2];\n}\n\n// When key pressed\nwindow.keyDown = function (e) {\n  // first four deal with player movement\n  if (e.keyCode === 39) {\n    keyState.right = true;\n  } else if (e.keyCode === 37) {\n    keyState.left = true;\n  } else if (e.keyCode === 38) {\n    keyState.up = true;\n  } else if (e.keyCode === 40) {\n    keyState.down = true;\n    // g - gravity\n  } else if (e.keyCode === 71) {\n    gameState.gravity = true;\n    gameState.repulsion = false;\n    pairwiseForceStrength = G;\n    // r - repulsion\n  } else if (e.keyCode === 82) {\n    gameState.gravity = false;\n    gameState.repulsion = true;\n    pairwiseForceStrength = R;\n    // f - vacuum state (f for frictionless)\n  } else if (e.keyCode === 70) {\n    gameState.drag = false;\n  }\n  if (player) player.updatePlayerForce();\n}\n\n//  When key released\nwindow.keyUp = function (e) {\n  if (e.keyCode === 39) {\n    keyState.right = false;\n  } else if (e.keyCode === 37) {\n    keyState.left = false;\n  } else if (e.keyCode === 38) {\n    keyState.up = false;\n  } else if (e.keyCode === 40) {\n    keyState.down = false;\n    // g\n  } else if (e.keyCode === 71) {\n    gameState.gravity = false;\n    pairwiseForceStrength = 0;\n    // r\n  } else if (e.keyCode === 82) {\n    gameState.repulsion = false;\n    pairwiseForceStrength = 0;\n    // f\n  } else if (e.keyCode === 70) {\n    gameState.drag = true;\n    // t - toggle teleport (blobs dissapear one side and reappear on the other)\n  } else if (e.keyCode === 84) {\n    gameState.borderTeleport = !gameState.borderTeleport;\n    if (gameState.borderTeleport) gameState.borderBounce = false;\n    // b - toggle border bounce\n  } else if (e.keyCode === 66) {\n    gameState.borderBounce = !gameState.borderBounce;\n    if (gameState.borderBounce) gameState.borderTeleport = false;\n    // z - this centres blobs on the middle of screen while maintaining their relative positions and velocities\n  } else if (e.keyCode === 90) {\n    zeroTotalMomentumAndPosition();\n    // a - add one blob on command\n  } else if (e.keyCode === 65) {\n    addBlob();\n  }\n  if (player) player.updatePlayerForce();\n}\n\n// when key pressed\nwindow.keyPress = function (e) {\n  // spacebar\n  if (e.keyCode === 32) {\n    if (!player) {\n      createPlayer();\n      toggleInstructions();\n    }\n  }\n}\n\n// shifts the velocity of all blobs to zero total momentum and centre COM in middle of screen while conserving relationships\nfunction zeroTotalMomentumAndPosition() {\n  let totalMomentum = [0, 0],\n    totalCOM = [0, 0],\n    totalMass = 0,\n    allBlobs = (player) ? blobs.concat([player]) : blobs;\n  // sum momentum, COM and mass\n  for (let i = 0; i < allBlobs.length; i++) {\n    let currentMass = allBlobs[i].getMass(),\n      currentVelocity = allBlobs[i].getVel(),\n      currentPosition = allBlobs[i].getPos();\n    totalMass += currentMass;\n    totalMomentum[0] += currentVelocity[0] * currentMass;\n    totalMomentum[1] += currentVelocity[1] * currentMass;\n    totalCOM[0] += currentPosition[0] * currentMass;\n    totalCOM[1] += currentPosition[1] * currentMass;\n  }\n  let velocityShift = [-totalMomentum[0] / totalMass, -totalMomentum[1] / totalMass],\n    positionShift = [initialPos[0] - totalCOM[0] / totalMass, initialPos[1] - totalCOM[1] / totalMass];\n\n  // adjust all blobs\n  for (let i = 0; i < allBlobs.length; i++) {\n    allBlobs[i].adjustVelocityBy(velocityShift);\n    allBlobs[i].adjustPositionBy(positionShift);\n  }\n}\n\n","import './globals'\nimport start from './game'\nwindow.onload = start"],"sourceRoot":""}